# tcp_pack_demo

这个demo是一种简便的解决方案用于解决TCP分包/粘包

TCP分包/粘包的问题, 本质上是同一个问题, 由于socket在发送或者接收数据的时候会等待缓冲区中的数据满了才会进行, 这个时候就会导致大包拆成多个小包, 或者多个小包被合成一个大包...

分包/粘包是不可避免的问题, 不管是在TCP层还是基于TCP之上的应用层,比如 HTTP 就采用了Content-Length 指定了数据的大小, 或者是 chunked 编码的方式, 还有回车换行 \r\n 分隔符...等等方式去避免/解决这个问题

tcp_pack_demo 是针对TCP分包/粘包的一种解决方案, 是在业务层定义的规范/协议针对这个问题的办法, 当然这不是唯一的办法, 比如还可以用换行符(或者约定的分隔符, JDK中socket相关的API就有readline()这样的方法进行解决)进行分隔......等等等等

这个demo的思路就是在业务数据前面附加一段 meta_data, 这个 meta_data (类似HTTP里头的 header)可以根据业务需要设置不同的元数据, 这个demo中meta_data只设置了真正的业务数据的长度, 比如业务上需要发送 "hello server" 这段数据, 这个时候需要在发送前计算一下这段字符的字节数为12, 如果我们定义meta_data的长度为4位(也可以更长, 更具业务需要定义规范/协议)在高位补 '0' 填充至4位即: 0012, 然后将 meta_data 拼在业务数据的前面, 那么数据将变成 "0012hello server"这样发送出去, 那么接收端在接收的时候会先读取前面4位(meta_data)以确定接下来需要从缓冲区中读取多少字节的数据......
